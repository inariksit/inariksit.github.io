---
layout: post
title:  "Agreement, part II: Addressee"
date:   2020-02-01
categories: gf
tags: "gf linguistics"
---

Aside from an explicit vocative and imperative, we don't really think of the addressee as an argument.
Yet it is there---usually a speech act is directed to some audience. So this is a thing that happens in some languages.

1. I eat-X some bread. (written in a personal diary, nobody sees it.)
1. I eat-X-SG2 your bread.
1. I eat-X-SG2 some bread. (addressed to someone)

The verb form for *eat* may or may not agree with *I* and *bread*---we mark that with the morpheme X. But crucially, in addition to the explicit arguments, it agrees with *you*. This raises a couple of questions:

* Are we dealing with morphosyntax or sociolinguistics?
* How should we model it in the GF RGL ([Resource Grammar Library](http://www.grammaticalframework.org/lib/doc/synopsis/index.html))?

Let us take two examples and I'll share my opinions.

## Politeness in Japanese

There's a funny passage from [Surely You're Joking, Mr. Feynman](https://books.google.se/books?id=Z7g-BAAAQBAJ&pg=PA245&dq=%22May+I+see+your+garden%22), about learning Japanese. (You can read the whole thing in the link.) Basically, Feynman learns that in order to translate a verb like *to see*, you have to know the whole context, who is talking to whom:


 &nbsp;                       | *my* garden | *your* (respectful) garden | *your* (extra respectful) garden
------------------------------|-------------|------------------------|------------------------------
__*I*&nbsp;see…&nbsp;__                 |             | "May I *observe* your *gorgeous* garden?" | "May I *hang my eyes on* your *most exquisite* gardens?" |
__*You*&nbsp;see…&nbsp;__                    | "Would you like to *glance at* my *lousy* garden?" | | |

<!-- * Do you want to see *my* garden -> "Would you like to glance at my lousy garden?"
* May I see *your* (standard level of politeness) garden -> "May I observe your gorgeous garden?"
* May I see *your* (extra polite) -> 'May I hang my eyes on your most exquisite gardens?' -->

Now, what does this mean in terms of GF? My take: if the politeness forms are different lexemes, most often we shouldn't put them in one lexicon entry _in the RGL_. We'd simply have a design as follows:

```haskell
fun
  glance_at_V2 : V2 ;
  observe_V2 : V2 ;
  hang_eyes_on_V2 : V2 ;
```

However, if the difference is morphological, then a good rule of thumb[^1] is to see them as one verb, and put all politeness forms in the same inflection table. Here I have 3 levels, plain, respecftul and extra respectful.

```haskell
fun
  see_V2 : V2 ;
lincat
  V2 = {s : Style => Str} ;
param
  Style = Plain | Resp | ExtraResp ;
lin
  see_V2 = {
    s = table {
      Plain     => "see.PLAIN" ; -- "glance at"
      Resp      => "see.RESP" ;  -- "observe"
      ExtraResp => "see.RESP+" ; -- "hang one's eyes on"
      } ;
  }
```



But inflection table is just the first step. We need to decide how to get those forms out---which GF constructors higher up in the tree select which forms? We have two alternatives:
<!-- How predictable is politeness from mere words or other constructors in the tree? Here are some ways to formulate rules: -->

1. Politeness is determined by combinations of words and other constructors in the tree. Extremely simplified example rules:
  * If object contains a polite word, such as `youPol_Pron` or `emperor_N`, choose `ExtraResp`. (Note that it doesn't have to be a direct object: a possessor is enough, like in *your garden*.)
  * If subject contains `i_Pron` and object contains `you{Sg,Pl}_Pron`, choose `Resp`.
  * If object contains `i_Pron`, choose `Plain`. <!--(even as a possessor, like in *my garden*)-->
1. Politeness is determined by factors beyond mere words and the common RGL constructors. It is best to keep all categories open for `Style` up to `S`. In the common core of the RGL, `UttS` will choose the most neutral one, and to access the others, we need to define the following functions in a language-specific extra module:
  * `PlainUtt,`
  * `RespectUtt,`
  * `ExtraRespUtt : S -> Utt ;`

If the RGL had been designed with Japanese in mind, it would certainly have these distinctions as abstract syntax functions in the common core. But as long as the different forms are available to application grammarians through *some* means---`ExtraJpn` or `ExtendJpn`---it's not a problem. I'll elaborate on that [later in this post](#controlling-politeness-in-an-application-grammar).

### Politeness in the RGL

Japanese has been in the RGL since 2012, so let's see how it works there. All credit for the actual code goes to Liza Zimina ([link to paper](https://link.springer.com/chapter/10.1007/978-3-642-33983-7_16)). Any misunderstandings about Japanese morphosyntax are mine.

#### Feynman's examples

Here's a simplified variant of Feynman's examples in the Japanese RG.

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lang&gt; p "I want to see the garden" | l -lang=Jpn
私       は  庭  を 見<span class="o">たい です</span>
<span class="c1">watashi wa niwa o mitai desu</span>

Lang&gt; p "she wants to see the garden" | l -lang=Jpn
彼女     は  庭  を 見<span class="o">たがって います</span>
<span class="c1">kanojo wa niwa o mitagatte imasu</span>
</code></pre></div></div>

If you look closely, you'll see different forms of the verb 見る 'to see'. Note that this difference is not person agreement! The form _mitagatte imasu_ reflects that I should be more respectful when talking about other people, but I can spend fewer morphemes (_mitai desu_) when talking about myself.[^2]

"But isn't that the definition of person agreement? You conjugate the verb differently when the subject is yourself vs. other people."

Sure, if it was the case that in all contexts, you always said _mitai desu_ about yourself and _mitagatte imasu_ about others, I too would call it person agreement. But that's not the case. In a context where everyone speaks politely, talking about yourself using polite morphology is normal. Contrast with English, where _I wants_ is wrong in all contexts.

(If you want to read the rest of the debate with the imaginary reader, follow the footnote.[^6])

<!--

In the previous example, "mitai" and "mitagatte" are actually forms of the same verb. You can see the stem 見 in both versions. But the verb may also be completely different. Let's see the verb `give_V3`.

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lang&gt; p "I give him the car" | l -lang=Jpn
私       は  彼  に   車     を 上げます
<span class="c1">watashi wa kare ni kuruma o agemasu</span>
<span class="c1">I    TOPIC him DAT car  OBJ give</span>

Lang&gt; p "he gives me the car" | l -lang=Jpn
彼    は   私      に  車     を 呉れます
<span class="c1">kare wa  watashi ni kuruma o kuremasu</span>
<span class="c1">he TOPIC me     DAT car  OBJ give</span>
</code></pre></div></div>

Here we have -->

<!--
```
Lang> p "I give him the car" | l -lang=Jpn
私 は 彼 に 車 を 上げます

Lang> p "he gives me the car" | l -lang=Jpn
彼 は 私 に 車 を 呉れます
```
```
Lang> p "I want to see Paris" | l -lang=Jpn
私 は 庭 を 見 たい です

Lang> p "he wants to see Paris" | l -lang=Jpn
彼 は 庭 を 見 たがって います
``` -->


<!--
In the Japanese RG, written by Liza Zimina ([link to paper](https://link.springer.com/chapter/10.1007/978-3-642-33983-7_16)), the solution is as follows---heavily simplified, apologies to the author for omitting all other points but the speaker distinction.-->

<!--

 ```haskell
param
  Speaker = Me | SomeoneElse ;
  Style = Plain | Resp ;

lincat
  NP = {s : Style => Str ; speaker : Speaker ; … } ;
  VP = {s : Speaker => Style => OtherParams => Str ; … } ;
  Cl = {s :            Style => OtherParams => Str ; … } ;

lin

  PredVP np vp = {
    s = \\style,… => np.s ! style ++
                     vp.s ! np.speaker ! style ! …
    } ;
```
-->

#### GF categories

Let's look at the types in GF. I have omitted parameters that are unrelated to politeness.


<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">param</span>
  <span class="kt">Speaker</span> <span class="o">=</span> <span class="kt">Me</span> <span class="o">|</span> <span class="kt">SomeoneElse</span> <span class="p">;</span>
  <span class="kt">Style</span> <span class="o">=</span> <span class="kt">Plain</span> <span class="o">|</span> <span class="kt">Resp</span> <span class="p">;</span>

<span class="n">lincat</span>
  <span class="kt">NP</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="n">speaker</span> <span class="o">:</span> <span class="kt">Speaker</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>
  <span class="kt">VP</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Speaker</span> <span class="o">=&gt;</span> <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="c1">…</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>
  <span class="kt">Cl</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span>            <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="c1">…</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>

<span class="n">lin</span>

  <span class="kt">PredVP</span> <span class="n">np</span> <span class="n">vp</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="o">\\</span><span class="n">style</span><span class="p">,</span><span class="c1">…</span> <span class="o">=&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">s</span> <span class="o">!</span> <span class="n">style</span> <span class="o">++</span>
                     <span class="n">vp</span><span class="o">.</span><span class="n">s</span> <span class="o">!</span> <span class="n">np</span><span class="o">.</span><span class="n">speaker</span> <span class="o">!</span> <span class="n">style</span> <span class="o">!</span> <span class="c1">…</span>
    <span class="p">}</span> <span class="p">;</span>
</code></pre></div></div>

There are, in fact, two dimensions in this sociolinguistic puzzle: the speaker and the overall style.
The Japanese resource grammar forces you to spend more morphemes when you talk about others, but you can still choose to do it in an overall more or less polite way. Here's the table for "__ want(s) to see the garden". (No need to know Japanese, just take it as longer = more polite.)


 &nbsp; | Plain | Respectful |
--------|-------|--------|---
 **Me**    | 私は庭を<strong>見たい</strong> | 私は庭を<strong>見たいです</strong>
 **SomeoneElse**  | 彼女は庭を<strong>見たがっている</strong> | 彼女は庭を<strong>見たがっています</strong>


Luckily, it's fairly easy to know if a NP is *me* or *someone else*---i.e. is the NP `UsePron i_Pron` or any other NP. So we can definitely choose the speaker in `PredVP`, and only be left with the overall style, when we reach `Cl`.

### Controlling politeness in an application grammar

In the Japanese RG, the `Style` parameter is open all the way up to `Utt`---finally, `PhrUtt` in  [PhraseJpn](https://github.com/GrammaticalFramework/gf-rgl/blob/master/src/japanese/PhraseJpn.gf#L8) chooses explicitly the `Resp`ectful style.
If you want to get the plain form, you need to use the function `StylePartPhr` in [ExtraJpn](https://github.com/GrammaticalFramework/gf-rgl/blob/master/src/japanese/ExtraJpn.gf#L36), which has the type signature `Level -> Part -> PConj -> Utt -> Voc -> Phr`.
Like all Extra and Extend functions, it is not exported in the API, so if you want to use it in your grammar, you need to open ExtraJpn in your concrete syntax and use it like this:

```haskell
concrete TestJpn of Test = open SyntaxJpn,
                               (E=ExtraJpn),
                               (P=PhraseJpn) in {
 lincat
   MyUtt = Utt ;
   MyPhr = Phr ;

 lin
   -- : MyUtt -> MyPhr ;
   MyPolitePhr utt = mkPhr utt ; -- use the API function
   MyPlainPhr utt = E.StylePartPhr E.Informal P.NoPConj
                                   E.PartGa utt P.NoVoc ;
}
```

I opened ExtraJpn qualified `(E=ExtraJpn)` and prefixed all functions from it with `E.`, so you can see the origins clearly.
The function `StylePartPhr`, as well as its argument categories `Level` (politeness level) and `Part` (particle) come from ExtraJpn. That makes sense: we define a function that is beyond the core RGL API, so then we also need to define its argument types and values, all in one module.

The only criticism I have for the type signature of `StylePartPhr` is that `PConj` (phrase-beginning conjunction, e.g. "therefore") and `Voc` (vocative[^3]) are obligatory. The only `Voc`s exported [in the API](http://www.grammaticalframework.org/lib/doc/synopsis/index.html#Voc) are `please_Voc` and `mkVoc : NP -> Voc`, so if we want to make a phrase without any eplicit addressee, we cannot use the API, but have to import another low-level RGL module, in this case PhraseJpn, to use its `NoVoc` construction. The same goes for `PConj`.
In contrast, the [API function `mkPhr`](http://www.grammaticalframework.org/lib/doc/synopsis/index.html#Phr) has this overload instance:

```haskell
mkPhr : (PConj) -> Utt -> (Voc) -> Phr ; -- but sleep, my friend
```

The arguments in parentheses mean that if you leave them out, they will be `NoPConj` and `NoVoc`.


## Allocutive agreement in Basque

In [part I](https://inariksit.github.io/gf/2020/05/14/agreement-1.html#ergative-absolutive-basque), we learned that Basque verbs mark their subject, object and indirect object in the verb form. And that's not all! In certain sociolinguistic contexts, Basque verbs mark also the addressee.
This marking of the addressee is called _allocutive agreement_.[^4]

First comes a short intro to Basque verbs, and then I will demonstrate allocutivity with a GF grammar. The code is available at [gf-agreement-tutorial/allocutive](https://github.com/inariksit/gf-agreement-tutorial/tree/master/allocutive). If you know Basque, please report any errors in this post. (There are simplifications and strategic omissions all over the place, but if you spot a genuine error, let me know!)

#### Basque verbs

<!-- Here's all you need to know to read this post about allocutivity. Some simplifications -->

Most Basque verbs inflect with a combination of a content-bearing participle and inflection-bearing auxiliary. Imagine if English verbs like _sleep_, _eat_ and _talk_ had no inflection, but you had to say _do sleeping_, _do eating_ and _do talking_. (In fact, English negation behaves like that: _I don't/she doesn't sleep/eat/talk_.)

Basque has several auxiliaries for different number of arguments---not a direct translation, but think _be sleeping_, _have eating_ and _give talking_. The auxiliaries are also used independently. In a context like _I am sleeping_, the intransitive _be_ is just an auxiliary, and without a participle, like _I am old_, it functions as a copula. (Notice how well this example worked in English too.)

<!-- There are only a handful of different auxiliaries in Basque. So a single inflection table may have hundreds of forms, but there are much fewer inflection tables than in your average language. -->

<!-- The sentences _I am sleeping_ and _I am_ only differ by the omission of the participle for _sleeping_. (English does that too: contrast _I am sleeping_ and _I am_.) -->

<!-- The auxiliaries (_✱-do_ part) inflect in hundreds of forms. As we knew from before, the auxiliary marks subject, direct object (if it has one) and indirect object (if it has one), in all tenses and moods. As we just have learned, it also marks the addressee,  -->
<!-- arking all 3 core arguments---and as we have learned, also the addressee. -->
<!--  _✱ing_ part (participle) only inflects in 3 forms. -->


#### No allocutive agreement

Let's start with the form that has no allocutive agreement. I could be talking to myself, or addressing a group of people.

```
> p "they are cats" | l -lang=Eus
katuak dira
```

_Katuak_ means 'cats',
<!-- in absolutive case (see Basque core cases in the [first agreement post](https://inariksit.github.io/gf/2020/05/14/agreement-1.html#ergative-absolutive-alignment)).  -->
and _dira_ is the intransitive auxiliary, inflected for a 3rd person plural subject. There's no subject pronoun: I've dropped all pronouns in my grammar, because all arguments are marked in the verb inflection.

(Basque word order is SOV, so if there was a subject pronoun, the whole sentence would be _hauek katuak dira_, 'they cats are'.)

#### Allocutive agreement with intransitive verbs

Now suppose I'm saying "they are cats" to a close friend of a binary gender. Then I need to use one of the following forms.

```
> p "they are cats ( spoken to a woman )" | l -lang=Eus
katuak ditun

> p "they are cats ( spoken to a man )" | l -lang=Eus
katuak dituk
```

These forms, _ditun_ for a woman and _dituk_ for a man, are an example of allocutive agreement. The form _ditun_ encodes a 3rd person plural argument (just like _dira_), and in addition, it encodes a 2nd person singular feminine argument---in this case[^5], the addressee. _Dituk_ is the same, just for a male addressee.


<!-- [](https://inariksit.github.io/gf/2020/05/14/agreement-1.html#ergative-absolutive-alignment) -->


#### Allocutive agreement with transitive verbs

The logic is exactly the same with transitive verbs. In the first example, I'm saying "I see cats" to nobody in particular; in the latter two, to a close friend or a family member.

```
> p "I see cats" | l -lang=Eus
katuak ikusi ditut

> p "I see cats ( spoken to a woman )" | l -lang=Eus
katuak ikusi ditinat

> p "I see cats ( spoken to a man )" | l -lang=Eus
katuak ikusi ditiat
```

For those curious about morphology, _ikusi_ is the participle of the verb _to see_, and _ditut/ditinat/ditiat_ are forms of the transitive auxiliary.

#### Allocutive agreement with ditransitive verbs

Ditransitive verbs work the same way. To add some interest, I omitted the last form, so if you never got to participate in linguistic olympiads, now is your chance to predict the ditransitive auxiliary form of "I give them cats", spoken to a man.

```
> p "I give them cats" | l -lang=Eus
katuei eman dizkiet

> p "I give them cats ( spoken to a woman )" | l -lang=Eus
katuei eman zizkienat

> p "I give them cats ( spoken to a man )" | l -lang=Eus
katuei eman ________
```

To check your answer, you can linearise the tree `PredVPMasc i_NP (ComplV3 give_V3 they_NP cats_NP)` in the [GF grammar](https://github.com/inariksit/gf-agreement-tutorial/tree/master/allocutive).

### Implementation in GF

These are the implementation details of my demo grammar at [gf-agreement-tutorial/allocutive](https://github.com/inariksit/gf-agreement-tutorial/tree/master/allocutive). I have simplified some things to concentrate on allocutivity, but the basic principles are the same in the actual Basque RG.
<!-- The actual Basque RG has lots of other, unrelated action. -->

<!-- If you are only interested in how to make allocutivity available in the RGL API, you can [jump to the next section](#allocutivity-in-the-rgl). Otherwise, keep reading. -->


#### lincats of `V*`

As mentioned [earlier in this post](#basque-verbs), Basque verbs consist of an auxiliary, which inflects in hundreds of forms, and a participle, which for the purposes of this grammar doesn't inflect.

With the lexical categories `V`, `V2` and `V3`, we only need to store the participle, so their lincat is as simple as `{s : Str}`.

```haskell
lincat
  V, V2, V3 = {s : Str} ; -- Invariant participle
```

In addition to the participle, `VP` contains a parameter [`ObjAgr`](https://github.com/inariksit/gf-agreement-tutorial/blob/master/allocutive/AllocutiveEus.gf#L109-L122)
, to record its origin (`V`, `V2` or `V3`) and the agreement of its objects.

```haskell
param
  ObjAgr = Intrans    -- No object
         | Trans Obj  -- Direct object (Sg1..Pl3)
         | Ditrans
              DObj    -- Direct object (only number)
              IObj ;  -- Indirect object (Sg1..Pl3)
lincat
  VP = {
    s : Str ;  -- Invariant participle + maybe object
    a : ObjAgr -- The object(s) agreement
    } ;
```

#### `UseV` and `ComplV*`

The objects are added in `ComplV*`: the string in the `s` field, and the agreement in the `a` field. `UseV` adds no objects, just the `ObjAgr` value `Intrans` to keep track that the `VP` is intransitive (i.e. it came from `V`).

```haskell
lin
  UseV v = v ** {
    a = Intrans
    } ;

  ComplV2 v2 obj = {
    s = obj.s ! Abs ++ v2.s ; -- OV word order
    a = Trans obj.a ; -- Obj. agreement kept in the VP
    } ;

  ComplV3 v3 dobj iobj = {
    s = dobj.s ! Abs ++ iobj.s ! Dat ++ v3.s ;
    a = Ditrans (agr2num dobj.a) iobj.a
    } ;
```

#### Inflection tables of the auxiliaries

We define [three types for inflection tables](https://github.com/inariksit/gf-agreement-tutorial/blob/master/allocutive/AllocutiveEus.gf#L128-L132) for the auxiliaries. These are not used as lincats, but only internally in functions of type `NP -> VP -> Cl`.

```haskell
oper
  Verb  : Type =                 Subj => Str ;
  Verb2 : Type =          Obj => Subj => Str ;
  Verb3 : Type = DObj => Subj => IObj => Str ;
```

These inflection tables match the `ObjAgr` param as follows, with subject agreement added.

| `ObjAgr`            | Inflection table              |
|---------------------|-------------------------------|
| `Intrans`           | `Subj => Str`                 |
| `Trans Obj`         | `Obj => Subj => Str`          |
| `Ditrans DObj IObj` | `DObj => Subj => IObj => Str` |

The non-allocutive auxiliaries are of types `Verb*`, and the allocutive auxiliaries are `Gender => Verb*`. I demonstrate below with the intransitive auxiliary---for the rest, you can imagine the same but with more nested tables.

```haskell
  intransAux : Verb = table {
    Sg1 => "naiz" ;
    {- ... -}
    Pl3 => "dira" } ;

  allocutive_intransAux : Gender => Verb = \\gend,agr =>
    transAux ! agr ! Sg2 gend ; -- Spurious Sg2 agreement
```

The intransitive case was easy to write, because all of the allocutive intransitives are also forms of the ordinary transitive auxiliary. But the general pattern is the same, regardless if we type every form by hand or borrow an already existing inflection table.
The allocutive version of the transitive auxiliary has 18 unique forms (in present indicative), and the rest are borrowed from the ditransitive auxiliary. I'm not going to paste it in the blog, but you can read the [source code](https://github.com/inariksit/gf-agreement-tutorial/blob/master/allocutive/AllocutiveEus.gf#L216-L251).

#### `NP -> VP -> Cl` functions

These auxiliaries are not a part of any GF category's lincat. They only exist as opers, and are called in the functions that create a clause from `NP` and `VP`. There are two considerations:

1. Which auxiliary to use? The answer is stored in `VP` in the `ObjAgr` parameter.
2. Allocutive or ordinary version of the auxiliary? The answer is in the choice of the `NP -> VP -> Cl` function.

The only change to the standard RGL is that I've added [two new functions](https://github.com/inariksit/gf-agreement-tutorial/blob/master/allocutive/Allocutive.gf#L37-L38) to form clauses.

```haskell
fun
  PredVP,    -- spoken to any audience or no audience
  PredVPFem, -- spoken to a woman
  PredVPMasc -- spoken to a man
    : NP -> VP -> Cl ;
```

The [implementations](https://github.com/inariksit/gf-agreement-tutorial/blob/master/allocutive/AllocutiveEus.gf#L63-L87) of the predication functions are identical, except for the concrete auxiliaries chosen. In `PredVP`, we have this local helper function:

```haskell
getAux : NounPhrase -> VerbPhrase -> Str = \np,vp ->
  case vp.a of {
    Intrans => intransAux ! ...
    Trans obj => transAux ! ...
    Ditrans dobj iobj => ditransAux ! ...
  } ;
```

and in `PredVP{Fem,Masc}` we have this instead:

```haskell
getAuxAllocutive : NounPhrase -> VerbPhrase -> Str = \g,np,vp ->
  case vp.a of {
    Intrans => allocutive_intransAux ! g ! ...
    Trans obj => allocutive_transAux ! g ! ...
    Ditrans dobj iobj => allocutive_ditransAux ! g ! ...
  } ;
```

If all verbs had different inflection tables, then I'd need to store inflection tables in the VPs. But in this grammar, all `VP`s with the same valency have the same auxiliary, so I can encode the auxiliary in a `param`, and have the actual inflection tables as free-floating opers. I'm not sure how much the GF compiler can optimise in this situation---the [actual strings](https://inariksit.github.io/gf/2018/06/13/pmcfg.html#sequences) won't be repeated, but I think there would be hundreds of redundant [labels](https://inariksit.github.io/gf/2018/06/13/pmcfg.html#concrete-categories) in the PGF. (Future work: write a naive version of this grammar and test how well GF compiler can optimise.)

Regardless of the performance, I think that this design is also nicer to read and write, and reflects the participle--auxiliary situation more accurately.

### Allocutivity in the RGL

This is a bit of an anticlimax, but allocutives are not yet implemented in the full Basque resource grammar. One day I'll have a GF retreat in a [Basque village by the sea](https://duckduckgo.com/?q=pasai+donibane&ia=images&iax=images) and don't emerge until the resource grammar is finished.

Once I implement the allocutives, I'm planning to use the same design I used in the demo grammar. I already have a param like `ObjAgr` in `VP`, and `PredVP` chooses the auxiliary, which have types just like `Verb`, `Verb2` and `Verb3`. So all I need to do is to add allocutive versions of the auxiliary opers, and then add `PredVPFem` and `PredVPMasc` in an Extra module only for Basque.

#### Why custom constructors

The core RGL was not prepared to encode addressee in the verb inflection. There is a sort of vocative construction with `VocNP`, but that's only for an explicit addressee: _I see cats, John_. That's not enough, we want to also express just _I see cats_ when you say it to someone without saying their name. So an explicit constructor is the only way to go.

<!-- In the case of Japanese, it was obvious from the syntax tree who is the speaker. So that's why it was possible to encode it as a rule in the grammar: the verb `see_V2` in _I want to see Paris_ is in a different form than `see_V2` in _she wants to see Paris_. -->

<!-- But in the case of Basque allocutive, it's impossible to know in which context a sentence is said. I can say "it's raining" to myself, or to an addressee. That's why in Basque, we implement the allocutive statements as extra constructions. In this mini grammar, I'm stopping at Cl, so we have the variants at the `NP -> VP -> Cl` level: -->



#### Why `Cl`

Why at the `Cl` level and not higher up? The biggest reason is the size of the inflection tables.

At `Cl`, we know already all core arguments to the verb: subject, object and indirect object.
But we're not done with inflection! There's still tense, mood, polarity, aspect and whether the clause is main or subordinate. If we kept allocutivity open, the table size would be multiplied by 3. That's because there are 3 options: no addressee, female addressee and male addressee.

Furthermore, it's no problem at all for the API to introduce the new `PredVP*` funs. Application grammarians only need to replace one `mkCl` with `Extra.PredVP*`, and the resulting `Cl` can be used just like any other `Cl`.


<!-- Number 1 concern: in which categories to keep allocutivity open? The inflection tables are massive. I checked against an existing morphological analyser, and it suggests that the ditransitive auxiliary has 334 forms that are not addressed to someone, and 396 forms that are---together 730 forms. I would much prefer a category with ~400 forms instead of 730 forms.[^4] -->


<!--
## Implications to the RGL API

Earlier, I said _as long as the different forms are available to application grammarians through *some* means---`ExtraJpn` or `Extend`---it's not a problem._

My suggestion is to keep `Utt` as

Utt is a {s : Str}, is easier to reuse other concrete syntaxes. Even though `Phr` is the start category, in many application grammars I find Utt to be the de facto start category. It makes sense, because S often needs to be open: think `SubjS : S -> Adv` which requires `S` to be open for mood (subjunctive vs. indicative), or `ComplVS : VS -> S -> VP`, which requires `S` to be open for word order (main vs. subordinate).
But after Utt, there's only vocatives to add, and I don't think I've ever seen one used in an application grammar.

Furthermore, often the grammars are written in a way that


Example: politeness, make it open until S, and choose one in `UttS`. Then communicate to your users that you need to have a custom `mkUtt` if you want other politeness forms.
Why just S?
- Would be much more complicated to drop politeness already at Cl level: a lot of hassle to change which forms get chosen at `UseCl` or `PredVP`. Both of these functions are complex and an end user should not need to touch internals that much.
- Would be API-breaking to keep politeness at Utt level. Adopting the language becomes a hassle, lot of grammars assume that Utt is a {s : Str}. Say you have a functor that takes care of a lot of things, and adding a new language is just adding lexicon. It's disappointing to plug in a new concrete and then have to override tons of things in your functor. In contrast, if Utt is {s:Str} and you want to change the politeness level, then you only need to override `mkUtt` from the RGL.

```haskell
demo application grammar showing how to override an API function like mkUtt
yes, there's a tiny bit of internals touching here, but wayyyy less than in option 1 and probably still less hassle than in option 2.
```
-->

## Conclusions

TODO

## Footnotes

[^1]: Of course, this is just a rule of thumb---inflection tables don't need to contain things that are morphologically related, nor is it a crime to separate them. *Kill* and *die* are semantically related, but we don't want to put them in the same inflection table.

[^2]: If you think this is weird, consider that even in English, people make linguistic distinctions based on if they're talking about themselves or others. For example, the names of parents: `father_N2` could have an inflection table `Me => "dad" ; SomeoneElse => "father"`.
<!-- Japanese has just grammaticalised this idea, and applied it to everything from word choice to verb inflection. -->

[^3]: If you're confused about the use of the word "vocative" in the GF RGL jargon, see [this post](https://groups.google.com/g/gf-dev/c/b0X8pgyxFSc/m/XdI4S75PAQAJ). In short: we call `please_Voc` and `VocNP (UsePN john_PN)` vocatives, because they turn any sentence into a vocative sentence. _"I'd like a cookie"_ and _it's raining_ can be said in any situation, but _"I'd like a cookie, please"_ and _"it's raining, John"_ are undoubtedly directed at someone.

[^4]: For a comprehensive introduction, see e.g. [Wikipedia](https://en.wikipedia.org/wiki/Allocutive_agreement) or [Antonov (2015)](https://core.ac.uk/download/pdf/47323396.pdf).


[^5]: In fact, _dituk_ and _ditun_ are ambiguous: in addition to being allocutive forms of the intransitive auxiliary, they are also the ordinary forms of the transitive auxiliary (with `Pl3` object and `Sg2{masc,fem}` subject). With transitive auxiliary, some (not all) of the allocutive forms are ambiguous with ordinary ditransitive auxiliary. With ditransitive auxiliary, there is no further auxiliary to be ambiguous with, so all ditransitive allocutive forms are unique, and genuinely encode 4 arguments.<br/><br/>(This was just a side note; whether the allocutive forms are unique or not, has no effect on how we implement it in GF.)

[^6]: _"Let's imagine that 'watashi wa … mitagatte imasu' were always socially inappropriate, and anyone who says that must be a foreigner or a total weirdo. Would you then call it person agreement?"_<br/><br/>If it's always inappropriate to talk about yourself politely, we can still ask whether people would get confused, or just offended. Contrast with a language that actually has person agreement. If I switched the subjects in English, the sentences would turn out as _*I wants […]_ and _*she want […]_. Most native speakers would argue that those are wrong on a purely grammatical level, not related to any social context.<br/><br/>_"I just said that only foreigners would say 'watashi wa … mitagatte imasu' in my hypothetical Japanese. Now you define that English has person agreement, because saying 'I wants' makes you sound like a foreigner?"_<br/><br/>I agree, sounding like a foreigner is a valuable clue for deeming something 'grammatically incorrect'. If a sociolinguistic rule creates gaps in the possible combinations of subject and verb form---literally nobody ever mixes the 3rd person and plain form, or 1st person and polite form---then in time it can grammaticalise into actual person agreement. As a further development, the formerly offensive deviations might even become neutral, like currently in English: <em>I&nbsp;wants</em> just says I don't speak the language well, not that I'm inappropriate.<br/><br/>_"There's nothing special about being offended about language use. Many people get irrationally angry about grammatical phenomena in English, like split infinitives."_<br/><br/>Look, you're going to like my 3rd post, where I'm going to claim that preposition contraction is person agreement. Now stop hijacking my footnotes and let the poor reader return to the main post.


<!-- [^5]: Technically the full `Valency` parameter is overkill in `V`, `V2` and `V3`, because all `V`s are intransitive, all `V2`s are transitive and so on. But `VP` needs the full type anyway, because it can come from any of `V{,2,3}`, so I put the `Valency` parameter already in the lexical categories to save me some keystrokes. The inefficiency is optimised away in the PGF, when compiled with `--optimize-pgf`. For example, `UseV` expands to only 1 concrete function (instead of 25 without optimisation), reflecting the fact that there's only one real valency alternative for `V`. -->

<!-- [^4]: Seriously, take a moment to appreciate the inflection tables. 730 forms for a single verb. In English, how many verb forms can you think of? To be, am, are, is, was, were, has been, had been, would be, would've been, be (imperative), being. I got up to 12, and I had to include periphrastic forms and homonyms. -->


<!-- When I've explained allocutive agreement to my more natural-science-oriented friends, two people have independently called it the linguistics version of [spooky action at a distance](https://www.google.com/search?q=spooky%20action%20at%20a%20distance). (No need to know what the physics version means to understand allocutives.) -->


<!--(Actually, Basque `V2` can take its subject in either ergative or dative, so in the full RG we do need a parameter even in the lexical categories. But in this simplified grammar, we only have ergative subjects for V2.)-->
