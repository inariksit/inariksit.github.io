---
layout: post
title:  "Agreement, part II: Addressee and other implicit arguments"
date:   2020-02-01
categories: gf
tags: "gf linguistics"
---

Aside from an explicit vocative and imperative, we don't really model the addressee as an argument.
Yet it is there---usually a speech act is directed to some audience. So this is a thing that happens in some languages.

1. I eat-X some bread. (written in a personal diary, nobody sees it.)
1. I eat-X-SG2 your bread.
1. I eat-X-SG2 some bread. (addressed to someone)

The verb form for *eat* may or may not agree with *I* and *bread*---we mark that with the morpheme X. But crucially, in addition to the explicit arguments, it agrees with *you*. This raises a couple of questions:

* Are we dealing with morphosyntax or sociolinguistics?
* How should we model it in the RGL ([Resource Grammar Library](http://www.grammaticalframework.org/lib/doc/synopsis/index.html))?

Let us take two examples and I'll share my opinions.

## Politeness in Japanese

There's a funny passage from [Surely You're Joking, Mr. Feynman](https://books.google.se/books?id=Z7g-BAAAQBAJ&pg=PA245&dq=%22May+I+see+your+garden%22), about learning Japanese. (You can read the whole thing in the link.) Basically, Feynman learns that in order to translate a verb like *to see*, you have to know the whole context, who is talking to whom:


 &nbsp;                       | *my* garden | *your* (respectful) garden | *your* (extra respectful) garden
------------------------------|-------------|------------------------|------------------------------
__*I*&nbsp;see…&nbsp;__                 |             | "May I *observe* your *gorgeous* garden?" | "May I *hang my eyes on* your *most exquisite* gardens?" |
__*You*&nbsp;see…&nbsp;__                    | "Would you like to *glance at* my *lousy* garden?" | | |

<!-- * Do you want to see *my* garden -> "Would you like to glance at my lousy garden?"
* May I see *your* (standard level of politeness) garden -> "May I observe your gorgeous garden?"
* May I see *your* (extra polite) -> 'May I hang my eyes on your most exquisite gardens?' -->

Now, what does this mean in terms of GF? My take: if the politeness forms are different lexemes, most often we shouldn't put them in one lexicon entry _in the RGL_. We'd simply have a design as follows:

```haskell
fun
  glance_at_V2 : V2 ;
  observe_V2 : V2 ;
  hang_eyes_on_V2 : V2 ;
```

However, if the difference is morphological, then a good rule of thumb[^1] is to see them as one verb, and put all politeness forms in the same inflection table. Here I have 3 levels, plain, respecftul and extra respectful.

```haskell
fun
  see_V2 : V2 ;
lincat
  V2 = {s : Style => Str} ;
param
  Style = Plain | Resp | ExtraResp ;
lin
  see_V2 = {
    s = table {
      Plain     => "see.PLAIN" ; -- "glance at"
      Resp      => "see.RESP" ;  -- "observe"
      ExtraResp => "see.RESP+" ; -- "hang one's eyes on"
      } ;
  }
```



But inflection table is just the first step. We need to decide how to get those forms out---which GF constructors higher up in the tree select which forms? We have two alternatives:
<!-- How predictable is politeness from mere words or other constructors in the tree? Here are some ways to formulate rules: -->

1. Politeness is determined by combinations of words and other constructors in the tree. Extremely simplified example rules:
  * If object contains a polite word, such as `youPol_Pron` or `emperor_N`, choose `ExtraResp`. (Note that it doesn't have to be a direct object: a possessor is enough, like in *your garden*.)
  * If subject contains `i_Pron` and object contains `you{Sg,Pl}_Pron`, choose `Resp`.
  * If object contains `i_Pron`, choose `Plain`. <!--(even as a possessor, like in *my garden*)-->
1. Politeness is determined by factors beyond mere words and the common RGL constructors. It is best to keep all categories open for `Style` up to `S`. In the common core of the RGL, `UttS` will choose the most neutral one, and to access the others, we need to define the following functions in a language-specific extra module:
  * `PlainUtt,`
  * `RespectUtt,`
  * `ExtraRespUtt : S -> Utt ;`

If the RGL had been designed with Japanese in mind, it would certainly have these distinctions as abstract syntax functions in the common core. But as long as the different forms are available to application grammarians through *some* means---`ExtraJpn` or `ExtendJpn`---it's not a problem. I'll elaborate on that [later in this post](TODO).

### Politeness in the RGL

Japanese has been in the RGL since 2012, so let's see how it works there. All credit for the actual code goes to Liza Zimina ([link to paper](https://link.springer.com/chapter/10.1007/978-3-642-33983-7_16)). Any misunderstandings about Japanese morphosyntax are mine.


I tried to replicate Feynman's example sentences in the Japanese resource grammar, but it seems that the distinction is implemented only for `VV` and `V3`. So here's how it works for "__ want(s) to see Paris".

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lang&gt; p "I want to see Paris" | l -lang=Jpn
私       は  パリ を 見<span class="o">たい です</span>
<span class="c1">watashi wa pari o mitai desu</span>

Lang&gt; p "she wants to see Paris" | l -lang=Jpn
彼女     は  パリ を 見<span class="o">たがって います</span>
<span class="c1">kanojo wa pari o mitagatte imasu</span>
</code></pre></div></div>

So what's the big deal---a verb inflects depending on the subject? But in fact, this is not person agreement. The form _mitagatte imasu_ reflects that I should be more respectful when talking about other people, but I can spend fewer morphemes (_mitai desu_) when talking about myself[^2].



<!--

In the previous example, "mitai" and "mitagatte" are actually forms of the same verb. You can see the stem 見 in both versions. But the verb may also be completely different. Let's see the verb `give_V3`.

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lang&gt; p "I give him the car" | l -lang=Jpn
私       は  彼  に   車     を 上げます
<span class="c1">watashi wa kare ni kuruma o agemasu</span>
<span class="c1">I    TOPIC him DAT car  OBJ give</span>

Lang&gt; p "he gives me the car" | l -lang=Jpn
彼    は   私      に  車     を 呉れます
<span class="c1">kare wa  watashi ni kuruma o kuremasu</span>
<span class="c1">he TOPIC me     DAT car  OBJ give</span>
</code></pre></div></div>

Here we have -->

<!--
```
Lang> p "I give him the car" | l -lang=Jpn
私 は 彼 に 車 を 上げます

Lang> p "he gives me the car" | l -lang=Jpn
彼 は 私 に 車 を 呉れます
```
```
Lang> p "I want to see Paris" | l -lang=Jpn
私 は パリ を 見 たい です

Lang> p "he wants to see Paris" | l -lang=Jpn
彼 は パリ を 見 たがって います
``` -->


<!--
In the Japanese RG, written by Liza Zimina ([link to paper](https://link.springer.com/chapter/10.1007/978-3-642-33983-7_16)), the solution is as follows---heavily simplified, apologies to the author for omitting all other points but the speaker distinction.-->

<!--

 ```haskell
param
  Speaker = Me | SomeoneElse ;
  Style = Plain | Resp ;

lincat
  NP = {s : Style => Str ; speaker : Speaker ; … } ;
  VP = {s : Speaker => Style => OtherParams => Str ; … } ;
  Cl = {s :            Style => OtherParams => Str ; … } ;

lin

  PredVP np vp = {
    s = \\style,… => np.s ! style ++
                     vp.s ! np.speaker ! style ! …
    } ;
```
-->

Let's look at the types. I have omitted parameters that are unrelated to politeness.


<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">param</span>
  <span class="kt">Speaker</span> <span class="o">=</span> <span class="kt">Me</span> <span class="o">|</span> <span class="kt">SomeoneElse</span> <span class="p">;</span>
  <span class="kt">Style</span> <span class="o">=</span> <span class="kt">Plain</span> <span class="o">|</span> <span class="kt">Resp</span> <span class="p">;</span>

<span class="n">lincat</span>
  <span class="kt">NP</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="n">speaker</span> <span class="o">:</span> <span class="kt">Speaker</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>
  <span class="kt">VP</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Speaker</span> <span class="o">=&gt;</span> <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="c1">…</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>
  <span class="kt">Cl</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span>            <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="c1">…</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>

<span class="n">lin</span>

  <span class="kt">PredVP</span> <span class="n">np</span> <span class="n">vp</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="o">\\</span><span class="n">style</span><span class="p">,</span><span class="c1">…</span> <span class="o">=&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">s</span> <span class="o">!</span> <span class="n">style</span> <span class="o">++</span>
                     <span class="n">vp</span><span class="o">.</span><span class="n">s</span> <span class="o">!</span> <span class="n">np</span><span class="o">.</span><span class="n">speaker</span> <span class="o">!</span> <span class="n">style</span> <span class="o">!</span> <span class="c1">…</span>
    <span class="p">}</span> <span class="p">;</span>
</code></pre></div></div>

There are, in fact, two dimensions in this sociolinguistic puzzle: the speaker and the overall style.
The Japanese resource grammar forces you to spend more morphemes when you talk about others, but you can still choose to do it in an overall more or less polite way. Here's the table for "__ want(s) to see Paris". (No need to know Japanese, just take it as longer = more polite.)


 &nbsp; | Plain | Respectful |
--------|-------|--------|---
 **Me**    | 私はパリを<strong>見たい</strong> | 私はパリを<strong>見たいです</strong>
 **SomeoneElse**  | 彼女はパリを<strong>見たがっている</strong> | 彼女はパリを<strong>見たがっています</strong>


Luckily, it's fairly easy to know if a NP is *me* or *someone else*---i.e. is the NP `UsePron i_Pron` or any other NP. So we can definitely choose the speaker in `PredVP`, and only be left with the overall style, when we reach `Cl`.

In the Japanese RG, the `Style` parameter is open all the way up to `Utt`---finally, `PhrUtt` in  [PhraseJpn](https://github.com/GrammaticalFramework/gf-rgl/blob/master/src/japanese/PhraseJpn.gf#L8) chooses explicitly the `Resp`ectful style.
If you want to get the plain form, you need to use the function `StylePartPhr` in [ExtraJpn](https://github.com/GrammaticalFramework/gf-rgl/blob/master/src/japanese/ExtraJpn.gf#L36), which has the type signature `Level -> Part -> PConj -> Utt -> Voc -> Phr`.
Like all Extra and Extend functions, it is not exported in the API, so if you want to use it in your grammar, you need to open ExtraJpn in your concrete syntax and use it like this:

```haskell
concrete TestJpn of Test = open SyntaxJpn,
                               (E=ExtraJpn),
                               (P=PhraseJpn) in {
 lincat
   MyUtt = Utt ;
   MyPhr = Phr ;

 lin
   -- : MyUtt -> MyPhr ;
   MyPolitePhr utt = mkPhr utt ; -- use the API function
   MyPlainPhr utt = E.StylePartPhr E.Informal P.NoPConj
                                   E.PartGa utt P.NoVoc ;
}
```

I opened ExtraJpn qualified `(E=ExtraJpn)` and prefixed all functions from it with `E.`, so you can see the origins clearly.
The function `StylePartPhr`, as well as its argument categories `Level` (politeness level) and `Part` (particle) come from ExtraJpn. That makes sense: we define a function that is beyond the core RGL API, so then we also need to define its argument types and values, all in one module.

The only criticism I have for the type signature of `StylePartPhr` is that `PConj` (phrase-beginning conjunction, e.g. "therefore") and `Voc` (vocative[^3]) are obligatory. The only `Voc`s exported [in the API](http://www.grammaticalframework.org/lib/doc/synopsis/index.html#Voc) are `please_Voc` and `mkVoc : NP -> Voc`, so if we want to make a phrase without any eplicit addressee, we cannot use the API, but have to import another low-level RGL module, in this case PhraseJpn, to use its `NoVoc` construction. The same goes for `PConj`.
In contrast, the [API function `mkPhr`](http://www.grammaticalframework.org/lib/doc/synopsis/index.html#Phr) has this overload instance:

```haskell
mkPhr : (PConj) -> Utt -> (Voc) -> Phr ; -- but sleep, my friend
```

The arguments in parentheses mean that if you leave them out, they will be `NoPConj` and `NoVoc`.


## Allocutive agreement in Basque

In [part I](https://inariksit.github.io/gf/2020/05/14/agreement-1.html#ergative-absolutive-basque), we learned that Basque verbs mark their subject, object and indirect object in the verb form. But that's not all! In certain sociolinguistic contexts, Basque verbs mark also the addressee.
This marking of the addressee is called _allocutive agreement_.[^4]

I will demonstrate with a GF grammar. The code is available at [gf-agreement-tutorial/allocutive](https://github.com/inariksit/gf-agreement-tutorial/tree/master/allocutive). If you know Basque, let me know if you find errors in this post. (There are simplifications and strategic omissions all over the place, but if you spot a genuine error, let me know!)

#### Basque verbs

<!-- Here's all you need to know to read this post about allocutivity. Some simplifications -->

Most Basque verbs inflect using an auxiliary. Imagine if English verbs like _sleep_, _eat_ and _talk_ had no inflection, but you had to say _do sleeping_, _do eating_ and _do talking_. (In fact, English negation behaves like that: _I don't/she doesn't sleep/eat/talk_.)

Basque has several auxiliaries for different number of arguments: think _intransitive-do sleeping_, _transitive-do eating_ and _ditransitive-do talking_. The auxiliaries also have a meaning independently, so we can translate the more accurately as _be sleeping_, _have eating_ etc. The sentences _I am sleeping_ and _I am_ only differ by the omission of the participle for _sleeping_. (English does that too: contrast _I am sleeping_ and _I am_.)

<!-- The auxiliaries (_✱-do_ part) inflect in hundreds of forms. As we knew from before, the auxiliary marks subject, direct object (if it has one) and indirect object (if it has one), in all tenses and moods. As we just have learned, it also marks the addressee,  -->
<!-- arking all 3 core arguments---and as we have learned, also the addressee. -->
<!--  _✱ing_ part (participle) only inflects in 3 forms. -->


#### No allocutive agreement

Let's start with the form that has no allocutive agreement. I could be talking to myself, or addressing a group of people.

```
> p "they are cats" | l -lang=Eus
katuak dira
```

_Katuak_ means 'cats',
<!-- in absolutive case (see Basque core cases in the [first agreement post](https://inariksit.github.io/gf/2020/05/14/agreement-1.html#ergative-absolutive-alignment)).  -->
and _dira_ is the intransitive auxiliary, inflected for a 3rd person plural subject. There's no subject pronoun: I've dropped all pronouns in my grammar, because all arguments are marked in the verb inflection.

(Basque word order is SOV, so if there was a subject pronoun, the whole sentence would be _hauek katuak dira_, 'they cats are'.)

#### Allocutive agreement with intransitive verbs

Now suppose I'm saying "they are cats" to a close friend of a binary gender. Then I need to use one of the following forms.

```
> p "they are cats ( spoken to a woman )" | l -lang=Eus
katuak ditun

> p "they are cats ( spoken to a man )" | l -lang=Eus
katuak dituk
```

These forms, _ditun_ for a woman and _dituk_ for a man, are an example of allocutive agreement. The form _ditun_ encodes a 3rd person plural argument (just like _dira_), and in addition, it encodes a 2nd person singular feminine argument---in this case[^5], the addressee. _Dituk_ is the same, just for a male addressee.


<!-- [](https://inariksit.github.io/gf/2020/05/14/agreement-1.html#ergative-absolutive-alignment) -->


#### Allocutive agreement with transitive verbs

The logic is exactly the same with transitive verbs. In the first example, I'm saying "I see cats" to nobody in particular; in the latter two, to a close friend or a family member.

```
> p "I see cats" | l -lang=Eus
katuak ikusi ditut

> p "I see cats ( spoken to a woman )" | l -lang=Eus
katuak ikusi ditinat

> p "I see cats ( spoken to a man )" | l -lang=Eus
katuak ikusi ditiat
```

#### Allocutive agreement with ditransitive verbs

Ditransitive verbs work the same way. To add some interest, I omitted the last form, so if you never got to participate in linguistic olympiads, now is your chance to predict the ditransitive auxiliary form of "I give them cats", spoken to a man.

```
> p "I give them cats" | l -lang=Eus
katuei eman dizkiet

> p "I give them cats ( spoken to a woman )" | l -lang=Eus
katuei eman zizkienat

> p "I give them cats ( spoken to a man )" | l -lang=Eus
katuei eman ________
```

To check your answer, you can linearise the tree `PredVPMasc i_NP (ComplV3 give_V3 they_NP cats_NP)` in the [GF grammar](https://github.com/inariksit/gf-agreement-tutorial/tree/master/allocutive).

### Implementation details

These are the implementation details of my demo grammar at [gf-agreement-tutorial/allocutive](https://github.com/inariksit/gf-agreement-tutorial/tree/master/allocutive). I have simplified many things to keep it relevant to just allocutivity.
<!-- The actual Basque RG has lots of other, unrelated action. -->

If you are only interested in how to make allocutivity available in the RGL API, you can [jump to the next section](#allocutivity-in-the-rgl). Otherwise, keep reading.


#### `V*` in GF

I said [earlier in this post](#basque-verbs) that the participle inflects in 3 forms. But in my small grammar, I only implement present indicative perfective inflection, so for the purposes of this post, we pretend that the participle doesn't inflect.

With the lexical categories `V`, `V2` and `V3`, we only need to store the participle, so their lincat is as simple as `{s : Str}`.

```haskell
lincat
  V, V2, V3 = {s : Str} ; -- Uninflected participle
```

In addition to the participle, `VP` contains a parameter [`ObjAgr`](https://github.com/inariksit/gf-agreement-tutorial/blob/master/allocutive/AllocutiveEus.gf#L108-L117)
, to record its origin (`V`, `V2` or `V3`) and the agreement of its objects.

```haskell
param
  ObjAgr = Intrans    -- No object
         | Trans Agr  -- Direct object (Sg1..Pl3)
         | Ditrans
              Number  -- Direct object (only number)
              Agr ;   -- Indirect object (Sg1..Pl3)
lincat
  VP = {
    s : Str ; -- Uninflected participle + maybe object
    a : ObjAgr -- The object(s) agreement
    } ;
```
The objects are added in `ComplV*`: the string in the `s` field, and the agreement in the `a` field. `UseV` adds no objects, just the `ObjAgr` value `Intrans` to keep track that the `VP` came from a `V`.

```haskell
lin
  UseV v = v ** {
    a = Intrans
    } ;

  ComplV2 v2 obj = {
    s = obj.s ! Abs ++ v2.s ; -- OV word order
    a = Trans obj.a ; -- Obj. agreement kept in the VP
    } ;

  ComplV3 v3 dir indir = {
    s = dir.s ! Abs ++ indir.s ! Dat ++ v3.s ;
    a = Ditrans (agr2num dir.a) indir.a
    } ;
```

#### `NP -> VP -> Cl` in GF

Next, we define [three types for inflection tables](https://github.com/inariksit/gf-agreement-tutorial/blob/master/allocutive/AllocutiveEus.gf#L123-L127). These are not used as lincats, but only internally in functions of type `NP -> VP -> Cl`.

```haskell
oper
  Verb  : Type =                  Agr => Str ; -- Subj
  Verb2 : Type =           Agr => Agr => Str ; -- D.obj, subj
  Verb3 : Type = Number => Agr => Agr => Str ; -- D.obj, i.obj, subj
```




### Allocutivity in the RGL

This is a bit of an anticlimax, but allocutives are not implemented in the full Basque resource grammar. One day I'll have a GF retreat in a [Basque village by the sea](https://duckduckgo.com/?q=pasai+donibane&ia=images&iax=images) and don't emerge until the resource grammar is finished. Until that, let me just tell you how I'd make it accessible if it was implemented in the resource grammar.

<!-- Number 1 concern: in which categories to keep allocutivity open? The inflection tables are massive. I checked against an existing morphological analyser, and it suggests that the ditransitive auxiliary has 334 forms that are not addressed to someone, and 396 forms that are---together 730 forms. I would much prefer a category with ~400 forms instead of 730 forms.[^4] -->


I wouldn't want to keep allocutivity open for too long, because the inflection tables are massive.
If we kept allocutivity open, then for every sentence like "I give them cats", we need to store 3 versions in all tenses, aspects and moods, depending on if we have an audience and of which gender.

So I would add custom constructors that construct a VP, like this:

```
PredVP,    -- spoken to any audience or no audience
PredVPFem, -- spoken to a woman
PredVPMasc -- spoken to a man
  : NP -> VP -> Cl ;
```



In the case of Japanese, it was obvious from the syntax tree who is the speaker. So that's why it was possible to encode it as a rule in the grammar: the verb `see_V2` in _I want to see Paris_ is in a different form than `see_V2` in _she wants to see Paris_.

But in the case of Basque allocutive, it's impossible to know in which context a sentence is said. I can say "it's raining" to myself, or to an addressee. That's why in Basque, we implement the allocutive statements as extra constructions. In this mini grammar, I'm stopping at Cl, so we have the variants at the `NP -> VP -> Cl` level:



## Implications to the RGL API

Earlier, I said _as long as the different forms are available to application grammarians through *some* means---`ExtraJpn` or `Extend`---it's not a problem._

My suggestion is to keep `Utt` as

Utt is a {s : Str}, is easier to reuse other concrete syntaxes. Even though `Phr` is the start category, in many application grammars I find Utt to be the de facto start category. It makes sense, because S often needs to be open: think `SubjS : S -> Adv` which requires `S` to be open for mood (subjunctive vs. indicative), or `ComplVS : VS -> S -> VP`, which requires `S` to be open for word order (main vs. subordinate).
But after Utt, there's only vocatives to add, and I don't think I've ever seen one used in an application grammar.

Furthermore, often the grammars are written in a way that


Example: politeness, make it open until S, and choose one in `UttS`. Then communicate to your users that you need to have a custom `mkUtt` if you want other politeness forms.
Why just S?
- Would be much more complicated to drop politeness already at Cl level: a lot of hassle to change which forms get chosen at `UseCl` or `PredVP`. Both of these functions are complex and an end user should not need to touch internals that much.
- Would be API-breaking to keep politeness at Utt level. Adopting the language becomes a hassle, lot of grammars assume that Utt is a {s : Str}. Say you have a functor that takes care of a lot of things, and adding a new language is just adding lexicon. It's disappointing to plug in a new concrete and then have to override tons of things in your functor. In contrast, if Utt is {s:Str} and you want to change the politeness level, then you only need to override `mkUtt` from the RGL.

```haskell
demo application grammar showing how to override an API function like mkUtt
yes, there's a tiny bit of internals touching here, but wayyyy less than in option 1 and probably still less hassle than in option 2.
```

## Footnotes

[^1]: Of course, this is just a rule of thumb---inflection tables don't need to contain things that are morphologically related, nor is it a crime to separate them. *Kill* and *die* are semantically related, but we don't want to put them in the same inflection table.

[^2]: If you think this is weird, consider that even in English, people might call their parents differently from other people's parents. So `father_N2` could have an inflection table `Me => "daddy" ; SomeoneElse => "father"`. Japanese has just grammaticalised this idea.

[^3]: If you're confused about the use of the word "vocative" in the GF RGL jargon, see [this post](https://groups.google.com/g/gf-dev/c/b0X8pgyxFSc/m/XdI4S75PAQAJ). In short: we call `please_Voc` and `VocNP (UsePN john_PN)` vocatives, because they turn any sentence into a vocative sentence. _"I'd like a cookie"_ and _it's raining_ can be said in any situation, but _"I'd like a cookie, please"_ and _"it's raining, John"_ are undoubtedly directed at someone.

[^4]: For a comprehensive introduction, see e.g. [Wikipedia](https://en.wikipedia.org/wiki/Allocutive_agreement) or [Antonov (2015)](https://core.ac.uk/download/pdf/47323396.pdf).


[^5]: In fact, _dituk_ and _ditun_ are ambiguous: in addition to being allocutive forms of the intransitive auxiliary, they are also the ordinary forms of the transitive auxiliary (with `Pl3` object and `Sg2{masc,fem}` subject). With transitive auxiliary, some (not all) of the allocutive forms are ambiguous with ordinary ditransitive auxiliary. With ditransitive auxiliary, there is no further auxiliary to be ambiguous with, so all ditransitive allocutive forms are unique, and genuinely encode 4 arguments.<br/><br/>(This was just a side note; whether the allocutive forms are unique or not, has no effect on how we implement it in GF.)

All allocutive forms of the intransitive auxiliary are ambiguous with the ordinary transitive auxiliary; some allocutives of the transitive auxiliary are ambiguous with ornot all allocutive form

<!-- [^5]: Technically the full `Valency` parameter is overkill in `V`, `V2` and `V3`, because all `V`s are intransitive, all `V2`s are transitive and so on. But `VP` needs the full type anyway, because it can come from any of `V{,2,3}`, so I put the `Valency` parameter already in the lexical categories to save me some keystrokes. The inefficiency is optimised away in the PGF, when compiled with `--optimize-pgf`. For example, `UseV` expands to only 1 concrete function (instead of 25 without optimisation), reflecting the fact that there's only one real valency alternative for `V`. -->

<!-- [^4]: Seriously, take a moment to appreciate the inflection tables. 730 forms for a single verb. In English, how many verb forms can you think of? To be, am, are, is, was, were, has been, had been, would be, would've been, be (imperative), being. I got up to 12, and I had to include periphrastic forms and homonyms. -->


<!-- When I've explained allocutive agreement to my more natural-science-oriented friends, two people have independently called it the linguistics version of [spooky action at a distance](https://www.google.com/search?q=spooky%20action%20at%20a%20distance). (No need to know what the physics version means to understand allocutives.) -->


<!--(Actually, Basque `V2` can take its subject in either ergative or dative, so in the full RG we do need a parameter even in the lexical categories. But in this simplified grammar, we only have ergative subjects for V2.)-->
