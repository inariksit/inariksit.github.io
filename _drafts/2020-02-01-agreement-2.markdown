---
layout: post
title:  "Agreement, part II: Addressee and other implicit arguments"
date:   2020-02-01
categories: gf
tags: "gf linguistics"
---

Aside from an explicit vocative and imperative, we don't really model the addressee as an argument.
Yet it is there---usually a speech act is directed to some audience. So this is a thing that happens in some languages.

1. I eat-X some bread. (written in a personal diary, nobody sees it.)
1. I eat-X-SG2 your bread.
1. I eat-X-SG2 some bread. (addressed to someone)

The verb form for *eat* may or may not agree with *I* and *bread*---we mark that with the morpheme X. But crucially, in addition to the explicit arguments, it agrees with *you*. This raises a couple of questions:

* Are we dealing with morphosyntax or sociolinguistics?
* Whatever it is, how should we model it in the RGL?

Let us take two examples and I'll share my opinions.

## Politeness

There's a funny passage from [Surely You're Joking, Mr. Feynman](https://books.google.se/books?id=Z7g-BAAAQBAJ&pg=PA245&dq=%22May+I+see+your+garden%22), about learning Japanese. (You can read the whole thing in the link.) Basically, Feynman learns that in order to translate a verb like *to see*, you have to know the whole context, who is talking to whom:


 &nbsp;                       | *my* garden | *your* (polite) garden | *your* (extra polite) garden
------------------------------|-------------|------------------------|------------------------------
__*I*&nbsp;see…&nbsp;__                 |             | "May I *observe* your *gorgeous* garden?" | "May I *hang my eyes on* your *most exquisite* gardens?" |
__*You*&nbsp;see…&nbsp;__                    | "Would you like to *glance at* my *lousy* garden?" | | |

<!-- * Do you want to see *my* garden -> "Would you like to glance at my lousy garden?"
* May I see *your* (standard level of politeness) garden -> "May I observe your gorgeous garden?"
* May I see *your* (extra polite) -> 'May I hang my eyes on your most exquisite gardens?' -->

Now, what does this mean in terms of GF? My take: if the politeness forms are different lexemes, then we shouldn't make them a part of the RGL. We'd simply have a design as follows:

```haskell
fun
  glance_at_V2 : V2 ;
  observe_V2 : V2 ;
  hang_eyes_on_V2 : V2 ;
```

However, if the difference is morphological, then a good rule of thumb[^1] is to see them as one verb, and put all politeness forms in the same inflection table.

```haskell
fun
  see_V2 : V2 ;
lincat
  V2 = {s : Style => Str} ;
param
  Style = Plain | Polite | Polite+ ;
lin
  see_V2 = {
    s = table {
          Plain => "see.PLAIN" ;  -- "glance at"
          Polite => "see.POL" ;   -- "observe"
          Polite+ => "see.POL+" ; -- "hang one's eyes on"
        } ;
  }
```



But inflection table is just the first step. We need to decide how to get those forms out---which GF constructors higher up in the tree select which forms? We have two alternatives:
<!-- How predictable is politeness from mere words or other constructors in the tree? Here are some ways to formulate rules: -->

1. Politeness is determined by combinations of words and other constructors in the tree. Extremely simplified example rules:
  * If object contains a polite word, such as `youPol_Pron` or `emperor_N`, choose `Polite+`. (Note that it doesn't have to be a direct object: a possessor is enough, like in *your garden*.)
  * If subject contains `i_Pron` and object contains `you{Sg,Pl}_Pron`, choose `Polite`.
  * If object contains `i_Pron`, choose `Plain`. <!--(even as a possessor, like in *my garden*)-->
1. Politeness is determined by factors beyond mere words and the common RGL constructors. It is best to keep all categories open for `Style` until `Utt`. In the common core of the RGL, `UttS` will choose the most neutral one, and to access the others, we need to define the following functions in a language-specific extra module:
  * `PlainUtt,`
  * `PoliteUtt,`
  * `Polite+Utt : S -> Utt ;`

If the RGL had been designed with Japanese in mind, it would certainly have these distinctions as abstract syntax functions in the common core. But as long as the different forms are available to application grammarians through *some* means---`ExtraJpn` or `Extend`---it's not a problem. I'll elaborate on that [later in this post](TODO).

### Actual RGL implementation

Japanese has been in the RGL since 2012, so let's see how it works there. All credit for the actual code goes to Liza Zimina ([link to paper](https://link.springer.com/chapter/10.1007/978-3-642-33983-7_16)), I'm just reporting the great work she's done. Any misunderstandings about Japanese in this blog post are mine.


I tried to replicate Feynman's example sentences in the Japanese RG, but it seems that the distinction isn't included for all verbs, only for `VV` and `V3`. So here's how it works for `want_VV`:

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lang&gt; p "I want to see Paris" | l -lang=Jpn
私       は  パリ を 見<span class="o">たい です</span>
<span class="c1">watashi wa pari o mitai desu</span>

Lang&gt; p "she wants to see Paris" | l -lang=Jpn
彼女     は  パリ を 見<span class="o">たがって います</span>
<span class="c1">kanojo wa pari o mitagatte imasu</span>
</code></pre></div></div>

If you didn't know Japanese, you'd be bored out of your mind right now. The verb inflects depending on the subject, stop the press! But in fact, this is not person agreement. The form reflects that I should be more respectful when talking about other people, but I can spend fewer morphemes when  talking about myself[^2].



<!--

In the previous example, "mitai" and "mitagatte" are actually forms of the same verb. You can see the stem 見 in both versions. But the verb may also be completely different. Let's see the verb `give_V3`.

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lang&gt; p "I give him the car" | l -lang=Jpn
私       は  彼  に   車     を 上げます
<span class="c1">watashi wa kare ni kuruma o agemasu</span>
<span class="c1">I    TOPIC him DAT car  OBJ give</span>

Lang&gt; p "he gives me the car" | l -lang=Jpn
彼    は   私      に  車     を 呉れます
<span class="c1">kare wa  watashi ni kuruma o kuremasu</span>
<span class="c1">he TOPIC me     DAT car  OBJ give</span>
</code></pre></div></div>

Here we have -->

<!--
```
Lang> p "I give him the car" | l -lang=Jpn
私 は 彼 に 車 を 上げます

Lang> p "he gives me the car" | l -lang=Jpn
彼 は 私 に 車 を 呉れます
```
```
Lang> p "I want to see Paris" | l -lang=Jpn
私 は パリ を 見 たい です

Lang> p "he wants to see Paris" | l -lang=Jpn
彼 は パリ を 見 たがって います
``` -->


<!--
In the Japanese RG, written by Liza Zimina ([link to paper](https://link.springer.com/chapter/10.1007/978-3-642-33983-7_16)), the solution is as follows---heavily simplified, apologies to the author for omitting all other points but the speaker distinction.-->

<!--

 ```haskell
param
  Speaker = Me | SomeoneElse ;
  Style = Plain | Resp ;

lincat
  NP = {s : Style => Str ; speaker : Speaker ; … } ;
  VP = {s : Speaker => Style => OtherParams => Str ; … } ;
  Cl = {s :            Style => OtherParams => Str ; … } ;

lin

  PredVP np vp = {
    s = \\style,… => np.s ! style ++
                     vp.s ! np.speaker ! style ! …
    } ;
```
-->

Let's look at a simplified version of the types.


<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">param</span>
  <span class="kt">Speaker</span> <span class="o">=</span> <span class="kt">Me</span> <span class="o">|</span> <span class="kt">SomeoneElse</span> <span class="p">;</span>
  <span class="kt">Style</span> <span class="o">=</span> <span class="kt">Plain</span> <span class="o">|</span> <span class="kt">Resp</span> <span class="p">;</span>

<span class="n">lincat</span>
  <span class="kt">NP</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="n">speaker</span> <span class="o">:</span> <span class="kt">Speaker</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>
  <span class="kt">VP</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span> <span class="kt">Speaker</span> <span class="o">=&gt;</span> <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="c1">…</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>
  <span class="kt">Cl</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="o">:</span>            <span class="kt">Style</span> <span class="o">=&gt;</span> <span class="c1">…</span> <span class="o">=&gt;</span> <span class="kt">Str</span> <span class="p">;</span> <span class="c1">…</span> <span class="p">}</span> <span class="p">;</span>

<span class="n">lin</span>

  <span class="kt">PredVP</span> <span class="n">np</span> <span class="n">vp</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="o">\\</span><span class="n">style</span><span class="p">,</span><span class="c1">…</span> <span class="o">=&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">s</span> <span class="o">!</span> <span class="n">style</span> <span class="o">++</span>
                     <span class="n">vp</span><span class="o">.</span><span class="n">s</span> <span class="o">!</span> <span class="n">np</span><span class="o">.</span><span class="n">speaker</span> <span class="o">!</span> <span class="n">style</span> <span class="o">!</span> <span class="c1">…</span>
    <span class="p">}</span> <span class="p">;</span>
</code></pre></div></div>

There are, in fact, two dimensions in this sociolinguistic puzzle: the speaker and the overall style.
The Japanese resource grammar forces you to spend more morphemes when you talk about others, but you can still choose to do it in an overall more or less polite way. Here's the table for "__ want(s) to see Paris". (If you can't read Japanese, just take it as longer = more polite.)


 &nbsp; | Plain | Respectful |
--------|-------|--------|---
 **Me**    | 私はパリを<strong>見たい</strong> | 私はパリを<strong>見たいです</strong>
 **SomeoneElse**  | 彼女はパリを<strong>見たがっている</strong> | 彼女はパリを<strong>見たがっています</strong>


Luckily, it's fairly easy to know if a NP is *me* or *someone else*---i.e. is the NP `UsePron i_Pron` or any other NP. So we can definitely choose the speaker in `PredVP`, and only be left with the overall style, when we reach `Cl`.

In the Japanese RG, the `Style` is open all the way up to `Phr`--finally, `PhrUtt` in  [PhraseJpn](https://github.com/GrammaticalFramework/gf-rgl/blob/master/src/japanese/PhraseJpn.gf#L8) chooses explicitly the `Resp`ectful style.
If you want to get the plain form, you need to use the function `StylePartPhr` in [ExtraJpn](https://github.com/GrammaticalFramework/gf-rgl/blob/master/src/japanese/ExtraJpn.gf#L36).

<!--
 The `Style` parameter can also be encoded in some things that are already in the RGL: there is `youSg_Pron`, `youPl_Pron` and `youPol_Pron`. Of course, there are a million other things that are not handled in the RGL---maybe we could infer that all NPs made out of `emperor_N` are respectful, but this is very much not the case for nouns in general.

So style should rather be a variable in both NPs and VPs.
-->

## Basque allocutives

## Implications to the RGL API

Earlier, I said _as long as the different forms are available to application grammarians through *some* means---`ExtraJpn` or `Extend`---it's not a problem._

My suggestion is to keep `Utt` as

Utt is a {s : Str}, is easier to reuse other concrete syntaxes. Even though `Phr` is the start category, in many application grammars I find Utt to be the de facto start category. It makes sense, because S often needs to be open: think `SubjS : S -> Adv` which requires `S` to be open for mood (subjunctive vs. indicative), or `ComplVS : VS -> S -> VP`, which requires `S` to be open for word order (main vs. subordinate).
But after Utt, there's only vocatives to add, and I don't think I've ever seen one used in an application grammar.

Furthermore, often the grammars are written in a way that


Example: politeness, make it open until S, and choose one in `UttS`. Then communicate to your users that you need to have a custom `mkUtt` if you want other politeness forms.
Why just S?
- Would be much more complicated to drop politeness already at Cl level: a lot of hassle to change which forms get chosen at `UseCl` or `PredVP`. Both of these functions are complex and an end user should not need to touch internals that much.
- Would be API-breaking to keep politeness at Utt level. Adopting the language becomes a hassle, lot of grammars assume that Utt is a {s : Str}. Say you have a functor that takes care of a lot of things, and adding a new language is just adding lexicon. It's disappointing to plug in a new concrete and then have to override tons of things in your functor. In contrast, if Utt is {s:Str} and you want to change the politeness level, then you only need to override `mkUtt` from the RGL.

```haskell
demo application grammar showing how to override an API function like mkUtt
yes, there's a tiny bit of internals touching here, but wayyyy less than in option 1 and probably still less hassle than in option 2.
```

## Footnotes

[^1]: Of course, this is just a rule of thumb---inflection tables don't need to contain things that are morphologically related, nor is it a crime to separate them. *Kill* and *die* are semantically related, but we don't want to put them in the same inflection table.

[^2]: If you think this is weird, consider that even in English, people might call their parents differently from other people's parents. So `father_N2` could have an inflection table `Me => "daddy" ; SomeoneElse => "father"`. Japanese has just grammaticalised this idea.
