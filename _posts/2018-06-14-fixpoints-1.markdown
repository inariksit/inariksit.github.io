---
layout: post
title:  "Fixpoints, part I"
date:   2018-06-14
categories: research
tags: research
---

So you're a grammar writer, and you've inherited an established
resource grammar. Say that someone decided to give all verb
subcategories the same lincat<sup>[1](#footnote)</sup>, so now your
intransitive verbs are cluttered with fields for direct, indirect,
sentential, adverbial and predicative complements and it just hurts
your sense of aesthetics.

You remember that GF lincats [compile to multiple concrete categories](https://inariksit.github.io/gf/2018/06/13/pmcfg.html),
for each combination of parameters. Thus you wonder: which combinations are
actually in use?

We could solve this problem in many ways (and honestly, in simpler
ways than I'm going to show). But bear with me--this is a lesson in thinking in
fixpoints, not a lesson in "does this make sense to model as a
fixpoint computation". Eventually we get to problems that *do* make
sense to model as fixpoint computation.

That said, let's get started!

## Fixpoints 1: How to see everything as a fixpoint computation

We can see GF categories as mutually recursive datatypes. This is
actual GF abstract syntax:

```haskell
cat
  V, V2, VA, VV, VS, VQ, ..., VP, AP, NP, QS, S ;
fun
  UseV    : V        -> VP ;
  ComplV2 : V2 -> NP -> VP ;
  ComplVA : VA -> AP -> VP ; 
  ComplVS : VS -> S  -> VP ;
  ComplVV : VV -> VP -> VP ;
  ComplVQ : VQ -> QS -> VP ;
```

Let's change the syntax of the functions slightly: put the goal
category to the left and remove arrows.

```haskell
VP ::= useV V
VP ::= complV2 V2 NP
VP ::= complVA VA AP
VP ::= complVV VV VP
VP ::= complVS VS S
VP ::= complVQ VQ QS
```

If you squint a bit, it kind of looks like a system of equations.

```
x1  = … x3 … x17 …
x2  = … x1 …
x3  = … x3 … x5 … x23 …
…
x30 = … x24 … x27 …
```

Now, let's move from the GF abstract syntax to the PMCFG concrete
categories. I've labeled the different concrete categories with
superscript numbers; we don't need to care about their actual content
just now.

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">VP</span><span class="kt">¹</span> <span class="o">::=</span> <span class="n">useV</span><span class="n">¹</span> <span class="kt">V</span><span class="kt">²</span>
<span class="kt">VP</span><span class="kt">³</span> <span class="o">::=</span> <span class="n">complVV</span><span class="n">³</span> <span class="kt">VV</span><span class="kt">⁴</span> <span class="kt">VP</span><span class="kt">⁵</span>
<span class="o">...</span>
<span class="kt">VP</span><span class="kt">⁵</span> <span class="o">::=</span> <span class="n">useV</span><span class="n">⁵</span> <span class="kt">V</span><span class="kt">⁶</span>
<span class="o">...</span>
<span class="kt">VP</span><span class="kt">⁷</span> <span class="o">::=</span> <span class="n">complVV</span><span class="n">⁷</span> <span class="kt">VV</span><span class="kt">⁸</span> <span class="kt">VP</span><span class="kt">¹</span>
</code></pre></div></div>

Before, at the GF level, we could just look at the lexicon and check
whether there is a `V`. But now we are not sure anymore whether we have
both `V²` and `V⁶`: maybe one of the concrete categories is
linguistically impossible.

The intuition here is: "Compute if a category is empty, given the
emptiness of its argument categories."

So we need some initial guesses for the values. Ultimately we want to
just know if a given category has a member or no, so we can deal with
Booleans. We give an initial value of `False` to all variables: that
is, "all categories are empty". Let's mark that with red text.

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">VP</span><span class="err">¹</span> <span class="o">::=</span> <span class="n">useV</span><span class="n">¹</span> <span class="err">V</span><span class="err">²</span>
<span class="err">VP</span><span class="err">³</span> <span class="o">::=</span> <span class="n">complVV</span><span class="n">³</span> <span class="err">VV</span><span class="err">⁴</span> <span class="err">VP</span><span class="err">⁵</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁵</span> <span class="o">::=</span> <span class="n">useV</span><span class="n">⁵</span> <span class="err">V</span><span class="err">⁶</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁷</span> <span class="o">::=</span> <span class="n">complVV</span><span class="n">⁷</span> <span class="err">VV</span><span class="err">⁸</span> <span class="err">VP</span><span class="err">¹</span>
</code></pre></div></div>

In fact, now that we're reduced to Booleans, we don't even need to
care about what the original GF functions *do* with their arguments.
So we can replace all of the GF functions with just a `&&`:

<div class="language-haskell highlighter-rouge"><div
class="highlight"><pre class="highlight"><code><span
class="err">VP</span><span class="err">¹</span> <span class="o">::=</span> <span class="err">V</span><span class="err">²</span>
<span class="err">VP</span><span class="err">³</span> <span
class="o">::=</span> <span class="err">VV</span><span
class="err">⁴</span> <span class="n">&&</span> <span class="err">VP</span><span class="err">⁵</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁵</span> <span
class="o">::=</span> <span class="err">V</span><span class="err">⁶</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁷</span> <span
class="o">::=</span> <span class="err">VV</span><span
class="err">⁸</span> <span class="n">&&</span> <span class="err">VP</span><span class="err">¹</span>
</code></pre></div></div>

How can a variable for a category turn into `True`? We find a member
of that category! On the first round, we've got to deal with the
lexical categories: `V²` and `V⁶` for intransitive verbs, `VV⁴` and
`VV⁸` for verbs with a `VP` complement. Say that `V²` and `VV⁸`
actually have values:

<div class="language-haskell highlighter-rouge"><div
class="highlight"><pre class="highlight"><code><span
class="err">VP</span><span class="err">¹</span> <span class="o">::=</span> <span class="kt">V²</span>
<span class="err">VP</span><span class="err">³</span> <span
class="o">::=</span> <span class="err">VV</span><span
class="err">⁴</span> <span class="n">&&</span> <span class="err">VP</span><span class="err">⁵</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁵</span> <span
class="o">::=</span> <span class="err">V</span><span class="err">⁶</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁷</span> <span
class="o">::=</span> <span class="kt">VV⁸</span> <span class="n">&&</span> <span class="err">VP</span><span class="err">¹</span>
</code></pre></div></div>

Now that some values have updated, we see if we can update other
values:

<div class="language-haskell highlighter-rouge"><div
class="highlight"><pre class="highlight"><code><span
class="kt">VP¹</span> <span class="o">::=</span> <span class="kt">V²</span>
<span class="err">VP</span><span class="err">³</span> <span
class="o">::=</span> <span class="err">VV</span><span
class="err">⁴</span> <span class="n">&&</span> <span class="err">VP</span><span class="err">⁵</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁵</span> <span
class="o">::=</span> <span class="err">V</span><span class="err">⁶</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁷</span> <span
class="o">::=</span> <span class="kt">VV⁸</span> <span class="n">&&</span> <span class="kt">VP¹</span>
</code></pre></div></div>

Now that `V²` was confirmed non-empty, `VP¹` became that too. Note
that there could be multiple ways to construct a `VP¹`, and they could
all be impossible except for one, but that's fine. All we need is that
there is at least one way to construct a `VP¹`, and then `VP¹` is
definitely non-empty.

(By the way, now that we're dealing with Booleans, isn't it just
obvious why Koen likes this? :-D)

Anyway, moving on--can we update some other values? Yes: the `VP¹` on
the right-hand side of `VP⁷` just got updated, which updates `VP⁷`.

<div class="language-haskell highlighter-rouge"><div
class="highlight"><pre class="highlight"><code><span
class="kt">VP¹</span> <span class="o">::=</span> <span class="kt">V²</span>
<span class="err">VP</span><span class="err">³</span> <span
class="o">::=</span> <span class="err">VV</span><span
class="err">⁴</span> <span class="n">&&</span> <span class="err">VP</span><span class="err">⁵</span>
<span class="o">...</span>
<span class="err">VP</span><span class="err">⁵</span> <span
class="o">::=</span> <span class="err">V</span><span class="err">⁶</span>
<span class="o">...</span>
<span class="kt">VP⁷</span> <span
class="o">::=</span> <span class="kt">VV⁸</span> <span class="n">&&</span> <span class="kt">VP¹</span>
</code></pre></div></div>

But after this step, nothing is going to change anymore, no matter how
much we recompute. In other words, we've found a fixed point!

## Other easy problems modelled as fixpoint computations

This was quite a trivial problem for two reasons: the values are
not changing after they get confirmed as True, and we had absolutely
no use for the actual GF functions (or the PMCFG versions of them).

Let's take another fairly trivial problem: **Is a category reachable from the top category?**

* Start value: False (all categories are non-reachable from the top category)
* Confirm that the top category is reachable from the top category.
* For each function whose *goal category* is confirmed reachable,
confirm its *argument categories* reachable.

We still don't need the details of the function,
just knowledge which arguments it takes. The values are still
Booleans, and don't change once they've become True.

Notice that the first problem was bottom-up: we started from several
terminal categories, and moved up all the way to the top category.
This time we start from the top, and confirm more and more lower-level
categories reachable. But the iterative process is the same in both cases.

Another one! **Are some fields always empty?**

* Start value: all fields in all categories are empty. Now the value
  is not a Boolean, it is instead a set of fields that are
  empty--which in the beginning is *all fields*.
* A field `s` in a terminal category `T` is non-empty, if there is some
  actual word with a non-empty string in `s`. When such a word
  is found, remove that field from the initial set of empty fields.
* A field `s'` in a non-terminal category `N` is non-empty, if there is
  some function `f : T¹ -> … -> Tⁿ -> N`, that uses at least one
  non-empty field from some `Tⁱ`, or alternatively, *introduces new
  strings* into `s'`.


Here we need the actual GF function, because we need to find out which
fields of its arguments it is using--it's not enough to know that the
argument *has* some fields with some properties. In fact, since
functions may not only use their arguments but also introduce new
strings, we definitely need all three pieces of information: the emptiness
status of the arguments' fields, which fields are used by `f`, and
whether `f` introduces new strings.


## Coming up next

In the next post, we model a harder problem in `gftest` as a fixpoint
computation: namely, context generation. Later we might also talk
about ways to make the actual computation smarter.


***

<a name="footnote">1</a>: "I skipped so much redundant code due to
[subtyping](https://inariksit.github.io/gf/2018/05/25/subtyping-gf.html)--look
at these ultra-generic functions!", said the original grammarian when
confronted about this decision.
